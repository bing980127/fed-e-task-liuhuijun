## Vue
### Vue 的基本使用
+ watch 如何深度监听？watch 监听引用类型，拿不到 oldVal
```js
export default {
    data() {
        return {
            name: '双越',
            info: {
                city: '北京'
            }
        }
    },
    watch: {
        name(oldVal, val) {
            // eslint-disable-next-line
            console.log('watch name', oldVal, val) // 值类型，可正常拿到 oldVal 和 val
        },
        info: {
            handler(oldVal, val) {
                // eslint-disable-next-line
                console.log('watch info', oldVal, val) // 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val
            },
            deep: true // 深度监听
        }
    }
}
```
+ v-for 和 v-if 不能一起使用
+ 事件修饰符，按键修饰符
![](./images/vue事件修饰符.png)
![](./images/vue按键修饰符.png)
+ 事件被绑定到哪里？
  1. event 是原生的
  2. 事件被挂载到当前元素，和 React 不一样
  3. 和 DOM 事件一样
+ props 和 $emit
  + props:
    + 父组件中的代码
    ```js
    <template>
        <div>
            <Input @add="addHandler"/>
            <List :list="list" @delete="deleteHandler"/>
        </div>
    </template>

    <script>
    import Input from './Input'
    import List from './List'

    export default {
        components: {
            Input,
            List
        },
        data() {
            return {
                list: [
                    {
                        id: 'id-1',
                        title: '标题1'
                    },
                    {
                        id: 'id-2',
                        title: '标题2'
                    }
                ]
            }
        },
        methods: {
            addHandler(title) {
                this.list.push({
                    id: `id-${Date.now()}`,
                    title
                })
            },
            deleteHandler(id) {
                this.list = this.list.filter(item => item.id !== id)
            }
        },
        created() {
            // eslint-disable-next-line
            console.log('index created')
        },
        mounted() {
            // eslint-disable-next-line
            console.log('index mounted')
        },
        beforeUpdate() {
            // eslint-disable-next-line
            console.log('index before update')
        },
        updated() {
            // eslint-disable-next-line
            console.log('index updated')
        },
    }
    </script>
    ```
    + 子组件中的代码：
    ```js
    <template>
        <div>
            <ul>
                <li v-for="item in list" :key="item.id">
                    {{item.title}}

                    <button @click="deleteItem(item.id)">删除</button>
                </li>
            </ul>
        </div>
    </template>

    <script>
    import event from './event'

    export default {
        // props: ['list']
        props: {
            // prop 类型和默认值
            list: {
                type: Array,
                default() {
                    return []
                }
            }
        },
        data() {
            return {

            }
        },
        methods: {
            deleteItem(id) {
                this.$emit('delete', id)
            },
            addTitleHandler(title) {
                // eslint-disable-next-line
                console.log('on add title', title)
            }
        },
        created() {
            // eslint-disable-next-line
            console.log('list created')
        },
        mounted() {
            // eslint-disable-next-line
            console.log('list mounted')

            // 绑定自定义事件
            event.$on('onAddTitle', this.addTitleHandler)
        },
        beforeUpdate() {
            // eslint-disable-next-line
            console.log('list before update')
        },
        updated() {
            // eslint-disable-next-line
            console.log('list updated')
        },
        beforeDestroy() {
            // 及时销毁，否则可能造成内存泄露
            event.$off('onAddTitle', this.addTitleHandler)
        }
    }
    </script>
    ```
  + $emit
  ```js
  // 子组件通过 $emit 触发父组件的方法
  this.$emit('add', this.title)
  ```
+ 组件间通讯——自定义事件
  + 这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。
  + 触发事件的组件用 event.$emit, 接收事件的组件用 event.$on 来绑定事件
  + Input 兄弟组件
  ```js
  // 调用自定义事件
  let event = new Vue()
  event.$emit('onAddTitle', this.title)
  ```
  + List 兄弟组件
  ```js
  mounted() {
    // eslint-disable-next-line
    console.log('list mounted')
    let event = new Vue()
    // 绑定自定义事件
    event.$on('onAddTitle', this.addTitleHandler)
  },
  beforeDestroy() {
      // 及时销毁，否则可能造成内存泄露
      event.$off('onAddTitle', this.addTitleHandler)
  }
  ```
+ 组件生命周期
  + 挂载阶段
    + beforeCrate
    + created(Vue 初始化结束了)
    + beforeMount
    + mounted（页面挂载结束了）
  + 更新阶段
    + beforeUpdate
    + updated
  + 销毁阶段
    + beforeDestroy
    + destroyed
  + created: 父组件先实例化，子组件在实例化
  + mountd、updated 和 destroyed：子组件先触发，父组件后触发
+ Vue 高级特性
  + 自己实现 v-model
  ```js
  <template>
      <!-- 例如：vue 颜色选择 -->
      <input type="text"
          :value="text1"
          @input="$emit('change1', $event.target.value)"
      >
      <!--
          1. 上面的 input 使用了 :value 而不是 v-model
          2. 上面的 change1 和 model.event1 要对应起来
          3. text1 属性对应起来
      -->
  </template>

  <script>
  export default {
      model: {
          prop: 'text1', // 对应 props text1
          event: 'change1'
      },
      props: {
          text1: String,
          default() {
              return ''
          }
      }
  }
  </script>
  ```
  + $nextTick
    + Vue 是异步渲染
    + data 改变之后，DOM 不会立刻渲染
    + $nextTick 会在 DOM 渲染之后被触发，以获取最新 DOM 节点
    ```js
    <template>
      <div id="app">
        <ul ref="ul1">
            <li v-for="(item, index) in list" :key="index">
                {{item}}
            </li>
        </ul>
        <button @click="addItem">添加一项</button>
      </div>
    </template>

    <script>
    export default {
      name: 'app',
      data() {
          return {
            list: ['a', 'b', 'c']
          }
      },
      methods: {
        addItem() {
            this.list.push(`${Date.now()}`)
            this.list.push(`${Date.now()}`)
            this.list.push(`${Date.now()}`)

            // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调
            // 3. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次
            this.$nextTick(() => {
              // 获取 DOM 元素
              const ulElem = this.$refs.ul1
              // eslint-disable-next-line
              console.log( ulElem.childNodes.length )
            })
        }
      }
    }
    </script>
    ```
  + slot
    + 基本使用
      + Index.vue 中的代码：
      ```js
      <template>
          <div>
              <p>vue 高级特性</p>

              <!-- slot -->
              <SlotDemo :url="website.url">
                  {{website.title}}
              </SlotDemo>
          </div>
      </template>

      <script>
      import SlotDemo from './SlotDemo'
      export default {
          components: {
              SlotDemo,
          },
          data() {
              return {
                  name: '双越',
                  website: {
                      url: 'http://ddddd.com/',
                      title: 'ddddd',
                      subTitle: 'dddddddd'
                  },
                  // NextTickName: "NextTick",
                  showFormDemo: false
              }
          }
      }
      </script>
      ```
      + SlotDemo 中的代码：
      ```js
      <template>
          <a :href="url">
              <slot>
                  默认内容，即父组件没设置内容时，这里显示
              </slot>
          </a>
      </template>

      <script>
      export default {
          props: ['url'],
          data() {
              return {}
          }
      }
      </script>
      ```
    + 作用域插槽
      + Index.vue 中的代码
      ```js
      <template>
          <div>
              <p>vue 高级特性</p>
              <hr>
              <ScopedSlotDemo :url="website.url">
                  <template v-slot="slotProps">
                      {{slotProps.slotData.title}}
                  </template>
              </ScopedSlotDemo>
          </div>
      </template>

      <script>
      import ScopedSlotDemo from './ScopedSlotDemo'
      export default {
          components: {
              ScopedSlotDemo,
          },
          data() {
              return {
                  name: '双越',
                  website: {
                      url: 'http://dddd.com/',
                      title: 'dddd',
                      subTitle: 'ddddd'
                  },
                  // NextTickName: "NextTick",
                  showFormDemo: false
              }
          }
      }
      </script>
      ```
      + ScopedSlotDemo.vue 中的代码：
      ```js
      <template>
          <a :href="url">
              <slot :slotData="website">
                  {{website.subTitle}} <!-- 默认值显示 subTitle ，即父组件不传内容时 -->
              </slot>
          </a>
      </template>

      <script>
      export default {
          props: ['url'],
          data() {
              return {
                  website: {
                      url: 'http://wangEditor.com/',
                      title: 'wangEditor',
                      subTitle: '轻量级富文本编辑器'
                  }
              }
          }
      }
      </script>
      ```
    + 具名插槽
      + ![](./images/具名插槽.png)
  + 动态组件
  ```js
  <template>
      <div>
          <p>vue 高级特性</p>
          <hr>

          <!-- 动态组件 -->
          <!-- <component :is="NextTickName"/> -->
      </div>
  </template>

  <script>
  import NextTick from './NextTick'
  export default {
      components: {
          NextTick
      },
      data() {
          return {
              NextTickName: "NextTick",
          }
      }
  }
  </script>
  ```
  + 异步组件
  ```js
  <template>
      <div>
          <p>vue 高级特性</p>
          <hr>

          
          <!-- 异步组件 -->
          <!-- <FormDemo v-if="showFormDemo"/>
          <button @click="showFormDemo = true">show form demo</button> -->
      </div>
  </template>

  <script>
  export default {
      components: {
          FormDemo: () => import('../BaseUse/FormDemo'),
      },
      data() {
          return {
              showFormDemo: false
          }
      }
  }
  </script>
  ```
  + keep-alive
    + 缓存组件
    + 频繁切换，不需要重复渲染
    + KeepAlive.vue 的代码：
    ```js
    <template>
        <div>
            <button @click="changeState('A')">A</button>
            <button @click="changeState('B')">B</button>
            <button @click="changeState('C')">C</button>

            <keep-alive> <!-- tab 切换 -->
                <KeepAliveStageA v-if="state === 'A'"/> <!-- v-show -->
                <KeepAliveStageB v-if="state === 'B'"/>
                <KeepAliveStageC v-if="state === 'C'"/>
            </keep-alive>
        </div>
    </template>

    <script>
    import KeepAliveStageA from './KeepAliveStateA'
    import KeepAliveStageB from './KeepAliveStateB'
    import KeepAliveStageC from './KeepAliveStateC'

    export default {
        components: {
            KeepAliveStageA,
            KeepAliveStageB,
            KeepAliveStageC
        },
        data() {
            return {
                state: 'A'
            }
        },
        methods: {
            changeState(state) {
                this.state = state
            }
        }
    }
    </script>
    ```
    + KeepAliveStageA 中的代码：
    ```js
    <template>
        <p>state A</p>
    </template>

    <script>
    export default {
        mounted() {
            // eslint-disable-next-line
            console.log('A mounted')
        },
        destroyed() {
            // eslint-disable-next-line
            console.log('A destroyed')
        }
    }
    </script>
    ```
    + KeepAliveStageB 中的代码：
    ```js
    <template>
        <p>state B</p>
    </template>

    <script>
    export default {
        mounted() {
            // eslint-disable-next-line
            console.log('B mounted')
        },
        destroyed() {
            // eslint-disable-next-line
            console.log('B destroyed')
        }
    }
    </script>
    ```
    + KeepAliveStageC 中的代码：
    ```js
    <template>
        <p>state C</p>
    </template>

    <script>
    export default {
        mounted() {
            // eslint-disable-next-line
            console.log('C mounted')
        },
        destroyed() {
            // eslint-disable-next-line
            console.log('C destroyed')
        }
    }
    </script>
    ```
  + mixin
    + 多个组件有相同的逻辑，抽离出来
    + mixin 并不是完美的解决方案，会有一些问题
      + 变量来源不明确，不利于阅读
      + 多 mixin 可能会造成命名冲突
      + mixin 和组件可能出现多对多的关系，复杂度较高
    + VUE3 提出的 Composition API 旨在解决这些问题
    + MixinDemo.vue 中的代码
    ```js
    <template>
        <div>
            <p>{{name}} {{major}} {{city}}</p>
            <button @click="showName">显示姓名</button>
        </div>
    </template>

    <script>
    import myMixin from './mixin'

    export default {
        mixins: [myMixin], // 可以添加多个，会自动合并起来
        data() {
            return {
                name: '双越',
                major: 'web 前端'
            }
        },
        methods: {
        },
        mounted() {
            // eslint-disable-next-line
            console.log('component mounted', this.name)
        }
    }
    </script>
    ```
    + mixin.js 中的代码：
    ```js
    export default {
        data() {
            return {
                city: '北京'
            }
        },
        methods: {
            showName() {
                // eslint-disable-next-line
                console.log(this.name)
            }
        },
        mounted() {
            // eslint-disable-next-line
            console.log('mixin mounted', this.name)
        }
    }
    ```
+ Vuex 使用
  + 概念：
    + state
    + getters
    + action
    + mutation
  + 用于 Vue 组件
    + dispatch
    + commit
    + mapState
    + mapGetters
    + mapActions
    + mapMutations
  + ![](./images/vuex.png)
+ Vue-router 使用
  + 路由模式：Hash、H5 history（需要 server 端支持）
    + ![](./images/vue-router路由模式.png)
  + 路由配置：动态路由、懒加载
    + ![](./images/vue-router动态路由.png)
    + ![](./images/vue-router路由懒加载.png)

## React
### React 的使用
+ 插入 html: `<p dangerouslySetInnerHTML={rawHtmlData}></p>`
+ event:
  1. event 是 SyntheticEvent ，模拟出来 DOM 事件所有能力
  2. event.nativeEvent 是原生事件对象
  3. 所有的事件，都被挂载到 document 上
  4. 和 DOM 事件不一样，和 Vue 事件也不一样
+ 受控组件
```js
// 受控组件
return <div>
    <p>{this.state.name}</p>
    <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for */}
    <input id="inputName" value={this.state.name} onChange={this.onInputChange}/>
</div>
```
+ setState 是同步还是异步:
```js
// 第二，不要直接修改 state ，使用不可变值 ----------------------------
// this.state.count++ // 错误
this.setState({
    count: this.state.count + 1 // SCU
})
// 操作数组、对象的的常用形式

// 第三，setState 可能是异步更新（有可能是同步更新） ----------------------------

this.setState({
    count: this.state.count + 1
}, () => {
    // 联想 Vue $nextTick - DOM
    console.log('count by callback', this.state.count) // 回调函数中可以拿到最新的 state
})
console.log('count', this.state.count) // 异步的，拿不到最新值

// setTimeout 中 setState 是同步的
setTimeout(() => {
    this.setState({
        count: this.state.count + 1
    })
    console.log('count in setTimeout', this.state.count)
}, 0)

// 自己定义的 DOM 事件，setState 是同步的。再 componentDidMount 中

// 第四，state 异步更新的话，更新前会被合并 ----------------------------

// 传入对象，会被合并（类似 Object.assign ）。执行结果只一次 +1
this.setState({
    count: this.state.count + 1
})
this.setState({
    count: this.state.count + 1
})
this.setState({
    count: this.state.count + 1
})

// 传入函数，不会被合并。执行结果是 +3
this.setState((prevState, props) => {
    return {
        count: prevState.count + 1
    }
})
this.setState((prevState, props) => {
    return {
        count: prevState.count + 1
    }
})
this.setState((prevState, props) => {
    return {
        count: prevState.count + 1
    }
})

// 第五：自定义事件中
bodyClickHandler = () => {
    this.setState({
        count: this.state.count + 1
    })
    console.log('count in body event', this.state.count)
}
componentDidMount() {
    // 自己定义的 DOM 事件，setState 是同步的
    document.body.addEventListener('click', this.bodyClickHandler)
}
```
+ react 组件生命周期
  + ![](./images/react组件生命周期.png)
+ 非受控组件
```js
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            flag: true,
        }
        this.nameInputRef = React.createRef() // 创建 ref
        this.fileInputRef = React.createRef()
    }
    render() {
        // // input defaultValue
        // return <div>
        //     {/* 使用 defaultValue 而不是 value ，使用 ref */}
        //     <input defaultValue={this.state.name} ref={this.nameInputRef}/>
        //     {/* state 并不会随着改变 */}
        //     <span>state.name: {this.state.name}</span>
        //     <br/>
        //     <button onClick={this.alertName}>alert name</button>
        // </div>

        // // checkbox defaultChecked
        // return <div>
        //     <input
        //         type="checkbox"
        //         defaultChecked={this.state.flag}
        //     />
        // </div>

        // file
        return <div>
            <input type="file" ref={this.fileInputRef}/>
            <button onClick={this.alertFile}>alert file</button>
        </div>

    }
    alertName = () => {
        const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.value) // 不是 this.state.name
    }
    alertFile = () => {
        const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.files[0].name)
    }
}

export default App
```
  + 使用场景
    + 必须手动操作 DOM 元素，setState 实现不了
    + 文件上传 `<input type="file" ref={this.fileInputRef}/>`
    + 某些富文本编辑器，需要传入 DOM 元素
  + 受控组件 VS 非受控组件
    + 优先使用受控组件，符合 React 设计原则
    + 必须手动操作 DOM 元素用非受控组件
+ Portals:
  + 组件默认会按照既定层次嵌套渲染
  + 如何让组件渲染到父组件以外
  ```js
  import React from 'react'
  import ReactDOM from 'react-dom'
  import './style.css'

  class App extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
          }
      }
      render() {
          // // 正常渲染
          // return <div className="modal">
          //     {this.props.children} {/* vue slot */}
          // </div>

          // 使用 Portals 渲染到 body 上。
          // fixed 元素要放在 body 上，有更好的浏览器兼容性。
          return ReactDOM.createPortal(
              <div className="modal">{this.props.children}</div>,
              document.body // DOM 节点
          )
      }
  }

  export default App
  ```
+ context:
  + 公共信息（语言、主题）如何传递给每个组件
  + 用 props 太繁琐，用 redux 小题大做
  ```js
  import React from 'react'

  // 创建 Context 填入默认值（任何一个 js 变量）
  const ThemeContext = React.createContext('light')

  // 底层组件 - 函数是组件
  function ThemeLink (props) {
      // const theme = this.context // 会报错。函数式组件没有实例，即没有 this

      // 函数式组件可以使用 Consumer
      return <ThemeContext.Consumer>
          { value => <p>link's theme is {value}</p> }
      </ThemeContext.Consumer>
  }

  // 底层组件 - class 组件
  class ThemedButton extends React.Component {
      // 指定 contextType 读取当前的 theme context。
      // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext
      render() {
          const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。
          return <div>
              <p>button's theme is {theme}</p>
          </div>
      }
  }
  ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。

  // 中间的组件再也不必指明往下传递 theme 了。
  function Toolbar(props) {
      return (
          <div>
              <ThemedButton />
              <ThemeLink />
          </div>
      )
  }

  class App extends React.Component {
      constructor(props) {
          super(props)
          this.state = {
              theme: 'light'
          }
      }
      render() {
          return <ThemeContext.Provider value={this.state.theme}>
              <Toolbar />
              <hr/>
              <button onClick={this.changeTheme}>change theme</button>
          </ThemeContext.Provider>
      }
      changeTheme = () => {
          this.setState({
              theme: this.state.theme === 'light' ? 'dark' : 'light'
          })
      }
  }

  export default App
  ```
+ 异步组件
  + import()
  + React.lazy(() => import('./ContextDemo'))
  + React.Suspense
  ```js
  import React from 'react'

  const ContextDemo = React.lazy(() => import('./ContextDemo'))

  class App extends React.Component {
      constructor(props) {
          super(props)
      }
      render() {
          return <div>
              <p>引入一个动态组件</p>
              <hr />
              <React.Suspense fallback={<div>Loading...</div>}>
                  <ContextDemo/>
              </React.Suspense>
          </div>

          // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速）
          // 2. 看 network 的 js 加载
      }
  }

  export default App
  ```
+ 性能优化
  + shouldComponentUpdate (简称 SCU)
    + ![](./images/SCU.png)
    + React 默认：父组件有更新，子组件则无条件也更新！！！
    + 性能优化对于 React 更加重要！
  + PureComponent 和 React.memo
  + 不可变值 immutable.js
    + 彻底拥抱 “不可变值”
    + 基于共享数据（不是深拷贝），速度好
    + 有一定的学习和迁移成本，按需使用
+ 关于组件公共逻辑的抽离
  + mixin, 已被 React 弃用
  + 高阶组件 HOC
    + ![](./images/HOC.png)
    ```js
    import React from 'react'

    // 高阶组件
    const withMouse = (Component) => {
        class withMouseComponent extends React.Component {
            constructor(props) {
                super(props)
                this.state = { x: 0, y: 0 }
            }
      
            handleMouseMove = (event) => {
                this.setState({
                    x: event.clientX,
                    y: event.clientY
                })
            }
      
            render() {
                return (
                    <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
                        {/* 1. 透传所有 props 2. 增加 mouse 属性 */}
                        <Component {...this.props} mouse={this.state}/>
                    </div>
                )
            }
        }
        return withMouseComponent
    }

    const App = (props) => {
        const a = props.a
        const { x, y } = props.mouse // 接收 mouse 属性
        return (
            <div style={{ height: '500px' }}>
                <h1>The mouse position is ({x}, {y})</h1>
                <p>{a}</p>
            </div>
        )
    }

    export default withMouse(App) // 返回高阶函数
    ```
  + Render Props
  ```js
  import React from 'react'
  import PropTypes from 'prop-types'

  class Mouse extends React.Component {
      constructor(props) {
          super(props)
          this.state = { x: 0, y: 0 }
      }
    
      handleMouseMove = (event) => {
        this.setState({
          x: event.clientX,
          y: event.clientY
        })
      }
    
      render() {
        return (
          <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
              {/* 将当前 state 作为 props ，传递给 render （render 是一个函数组件） */}
              {this.props.render(this.state)}
          </div>
        )
      }
  }
  Mouse.propTypes = {
      render: PropTypes.func.isRequired // 必须接收一个 render 属性，而且是函数
  }

  const App = (props) => (
      <div style={{ height: '500px' }}>
          <p>{props.a}</p>
          <Mouse render={
              /* render 是一个函数组件 */
              ({ x, y }) => <h1>The mouse position is ({x}, {y})</h1>
          }/>
          
      </div>
  )

  /**
  * 即，定义了 Mouse 组件，只有获取 x y 的能力。
  * 至于 Mouse 组件如何渲染，App 说了算，通过 render prop 的方式告诉 Mouse 。
  */

  export default App
  ```
  + HOC vs Render Props
    + HOC:模式简单，但会增加组件层级
    + Render Props:代码简洁吗，学习成本较高
+ Redux 单项数据流概述
  1. dispatch(action)
  2. reducer -> newState
  3. subscribe 触发通知
  + ![](./images/redux数据流图.png)
+ react-redux 知识点：
  + ![](./images/react-redux.png)
  + index.js 中创建 store
  ```js
  import React from 'react'
  import { Provider } from 'react-redux'
  import { createStore } from 'redux'
  import todoApp from './reducers'
  import App from './components/App'

  let store = createStore(todoApp)

  export default function () {
      return <Provider store={store}>
          <App />
      </Provider>
  }
  ```
  + 单个文件中使用 redux:
  ```js
  import React from 'react'
  import { connect } from 'react-redux'
  import { addTodo } from '../actions'

  // 函数组件，接收 props 参数
  let AddTodo = ({ dispatch }) => {
    // dispatch 即 props.dispatch

    let input

    return (
      <div>
        <form
          onSubmit={e => {
            e.preventDefault()
            if (!input.value.trim()) {
              return
            }
            // 创建一个 todo
            dispatch(addTodo(input.value))
            input.value = ''
          }}
        >
          <input
            ref={node => {
              input = node
            }}
          />
          <button type="submit">
            Add Todo
          </button>
        </form>
      </div>
    )
  }

  // connect 高阶组件 ，将 dispatch 作为 props 注入到 AddTodo 组件中
  AddTodo = connect()(AddTodo)

  export default AddTodo
  ```
  ```js
  import { connect } from 'react-redux'
  import { toggleTodo } from '../actions'
  import TodoList from '../components/TodoList'

  // 不同类型的 todo 列表
  const getVisibleTodos = (todos, filter) => {
    switch (filter) {
      case 'SHOW_ALL':
        return todos
      case 'SHOW_COMPLETED':
        return todos.filter(t => t.completed)
      case 'SHOW_ACTIVE':
        return todos.filter(t => !t.completed)
    }
  }

  const mapStateToProps = state => {
    // state 即 vuex 的总状态，在 reducer/index.js 中定义
    return {
      // 根据完成状态，筛选数据
      todos: getVisibleTodos(state.todos, state.visibilityFilter)
    }
  }

  const mapDispatchToProps = dispatch => {
    return {
      // 切换完成状态
      onTodoClick: id => {
        dispatch(toggleTodo(id))
      }
    }
  }

  // connect 高阶组件，将 state 和 dispatch 注入到组件 props 中
  const VisibleTodoList = connect(
    mapStateToProps,
    mapDispatchToProps
  )(TodoList)

  export default VisibleTodoList
  ```
  + 异步 action:
    + ![](./images/异步action.png)
+ Redux 中间件：
  + ![](./images/redux中间件.png)
+ react-router:
  + ![](./images/react-router.png)

### React 原理
+ vnode 数据结构
  + ![](./images/vnode.png)
+ 合成事件：
  + ![](./images/react合成事件.png)
  + 为何要合成事件机制
    + 更好的兼容性和跨平台
    + 挂载到 document 上，减少了内存消耗，避免频繁解绑
    + 方便事件的统一管理（如事务机制）
+ batchUpdate:
  + setState:
    + 有时异步（普通使用），有时同步（setTimeout、DOM 事件）
    + 有时合并（对象形式），有时不合并（函数形式）
    + ![](./images/setState主流程.png)
    + ![](./images/isBatchingUpdates.png)
+ react-fiber 如何优化性能：
  + 将 reconciliation 阶段进行任务拆分（commit 无法拆分）
  + DOM 需要渲染时暂停，空闲时恢复
  + window.requestIdleCallback 回调


#### React 面试题
+ React 性能优化
  + 渲染列表时加 key
  + 自定义事件、DOM 事件及时销毁
  + 合理使用异步组件
  + 减少函数 bind this 的次数
  + 合理使用 scu、PureComponent 和 memo
  + 合理使用 Immutable.js
  + webpack 层面的优化
  + 前端通用的性能优化，如图片懒加载
+ React 和 Vue
  + 相同点：
    + 都支持组件化
    + 都是数据驱动视图
    + 都使用 vdom 操作 DOM
  + 不同点：
    + React 使用 JSX 拥抱 JS，Vue 使用模板拥抱 html
    + React 函数式编程，Vue 声明式编程
    + React 更多需要自力更生，Vue 把想要的都给你
+ hooks: 
  + 会有 Capture Value 特性
  + 推荐配合 `eslint-plugin-react-hooks` 使用
  + useEffect:
    + useEffect 依赖一个空数组的时候，会记住 state 的值
    ```js
    useEffect(()=>{
      setInterval(() => {
        console.log(num)
        setNum(num+1)
      }, 500);
    },[])
    // 一直打印 0，依赖空数组时，这个 effect 会记住 num 的值，每次都是 0
    ```
    + useEffect 依赖的数组里有值时，每次依赖项更新时，会把更新的值传给 effect 并重新执行 effect 里面的代码
    ```js
      useEffect(()=>{
        setInterval(() => {
          console.log(num)
          setNum(num+1)
        }, 500);
      },[num])
    ```
    + useEffect 里面不加 return 时，useEffect 中的代码块相当于在 class 组件的 componentDidMount 和 componentDidUpdate 中的代码块；加了 return 后，return 后的代码块相当于 class 组件里的 componentWillUnmount 中的代码块
    ```js
      useEffect(()=>{
        const timer = setInterval(() => {
          console.log(num)
          setNum(num+1)
        }, 500);
        return ()=>clearInterval(timer)
      },[num])
    ```
  + useRef:
    + 代码如下：
    ```js
    useEffect(()=>{
      countRef.current = count
    },[count])
    useEffect(()=>{
      const timer = setInterval(() => {
        console.log(countRef)
        setCount(countRef.current+1)
      }, 500);
      return ()=>clearInterval(timer)
    },[])
    ```
    ```js
    const btnRef = useRef(null)
    useEffect(()=>{
      const handleClick = ()=>{
        setCount(count+1)
      }
      btnRef.current.addEventListener('click',handleClick,false);
      return ()=>{
        btnRef.current.removeEventListener('click', handleClick,false);
      }
    },[count])
    return (
      <div>
        <p>count: {count}</p>
        <button ref={btnRef}>+1</button>
      </div>
    )
    ```
  + memo: 相当于 pureComponent
  ```js
  // 只传一个参数
  import React, {useState, useEffect, useRef, memo} from 'react';
  const Child = memo(()=> {
    return (
      <div>
        fffffff
      </div>
    )
  })
  // 传了两个参数，第二个参数相当于 shouldComponentUpdate
  import React, {useState, useEffect, useRef, memo} from 'react';
  const Child = memo(()=> {
    return (
      <div>
        fffffff
      </div>
    )
  },(prev,next)=>{
    return prev.count === next.count
  })
  ```
  + useMemo: 缓存的一个值
  ```js
  const Child = memo((props)=> {
    console.log(props)
    const date = new Date()
    return (
      <div>
        当前时间：{date.getHours()}: {date.getMinutes()}: {date.getSeconds()}
      </div>
    )
  })
  const Parent = ()=> {
    const [count, setCount] = useState(0)
    const [clickTimeCount, setTimeClickCount] = useState(0)
    const timeOption = useMemo(()=>{
      return {
        clickTimeCount
      }
    },[clickTimeCount])
    return (
      <div>
        <div>count: {count}</div>
        <button onClick={()=>{
          setCount(count+1)
        }}>+1</button>
        <button onClick={()=>{
          setTimeClickCount(clickTimeCount+1)
        }}>GET CURRENT TIME</button>
        <Child count={timeOption}/>
      </div>
    )
  }
  ```
  + useCallback: 缓存的是一个函数
  ```js
  import React, {useState, useEffect, useRef, memo, useMemo, useCallback} from 'react';
  const Child = memo((props)=> {
    console.log(props)
    const date = new Date()
    return (
      <div>
        当前时间：{date.getHours()}: {date.getMinutes()}: {date.getSeconds()}
        <input type="text" onChange={props.onChange}/>
      </div>
    )
  })
  const Parent = ()=> {
    const [count, setCount] = useState(0)
    const [text, setText] = useState('')
    const [clickTimeCount, setTimeClickCount] = useState(0)
    const handleOnchange = useCallback( (e)=>{
      setText(e.target.value)
    },[])

    return (
      <div>
        <div>count: {count}</div>
        <div>text: {text}</div>

        <button onClick={()=>{
          setCount(count+1)
        }}>+1</button>
        <button onClick={()=>{
          setTimeClickCount(clickTimeCount+1)
        }}>GET CURRENT TIME</button>
        <Child count={clickTimeCount} onChange={handleOnchange}/>
      </div>
    )
  }
  ```
  + 自定义 hooks: 通用逻辑抽离
    + 新建一个 hooks.js 文件，代码如下：
    ```js
    import {useState,useEffect} from 'react'

    export const useWindowSize = () => {
      const [width, setWidth] = useState('0px')
      const [height, setHeight] = useState('0px')
      useEffect(()=>{
        setWidth(document.documentElement.clientWidth+ 'px')
        setHeight(document.documentElement.clientHeight+ 'px')
      },[])
      useEffect(()=>{
        const handleResize = ()=>{
          setWidth(document.documentElement.clientWidth+ 'px')
          setHeight(document.documentElement.clientHeight+ 'px')
        }
        window.addEventListener('resize',handleResize,false)
        return ()=>{
          window.removeEventListener('resize',handleResize,false)
        }
      },[])
      return [width, height]
    }
    ```
    + 别的组件中引用这个自定义 hooks：
  ```js
  import React, {useState, useEffect, useRef, memo, useMemo, useCallback} from 'react';
  import {useWindowSize} from './hooks'
  const Parent = ()=> {
    const [width, height] = useWindowSize()
    return (
      <div>
        size:{width} * {height}
      </div>
    )
  }

  function App() {
    return (
      <div className="App">
        <Parent />
      </div>
    );
  }
  export default App;
  ```
  + useReducer、useContext:
  ```js
  import React, {useReducer,useContext} from 'react';

  const Ctx = React.createContext(null)
  const reducer = (state,action) => {
    switch (action.type) {
      case 'ADD':
        return state + 1
      case 'SUB':
        return state - 1
      default:
        return state
    }
  }
  const Child = ()=>{
    const [count, dispatch] = useContext(Ctx)
    return (
      <div>
        child: count: {count}
        <button onClick={()=>dispatch({type:'ADD'})}>+1</button>
        <button onClick={()=>dispatch({type:'SUB'})}>-1</button>
      </div>
    )
  }
  const Parent = ()=> {
    const [count, dispatch] = useContext(Ctx)
    return (
      <div>
        Parent: {count}
        <Child />
      </div>
    )
  }

  function App() {
    const [count, dispatch] = useReducer(reducer, 20)
    return (
      <Ctx.Provider value={[count, dispatch]}>
        <div className="App">
          <Parent />
        </div>
      </Ctx.Provider>
    );
  }
  export default App;
  ```
  + useSelector(mapStateToProps)、useDispatch(mapDispatchToProps)：
  ```js
  import React from 'react'
  import {useSelector, useDispatch} from 'react-redux'
  import {updateName, updateTel} from './action'
  export default ()=>{
    const formData = useSelector(state => {
      console.log(state)
      return state.form
    })
    const dispatch = useDispatch()
    return (
      <div>
        form: <br />
        姓名： <input type='text' onChange={e=>{dispatch(updateName(e.target.value))}} /><br />
        电话： <input type='tel' onChange={e=>{dispatch(updateTel(e.target.value))}} /><br />
      </div>
    )
  }
  ```
+ redux
  1. store: 存放数据的仓库
  2. state: 数据仓库当中存储的数据
  3. action: 操作数据的行为对象
  4. dispatch: store.dispatch(action),唯一的更改 state 的方法
  5. reducer: 根据 dispatch 过来的 action 来更新 state 的值
+ react-redux 
  + 展示组件
  + 容器组件：


## webpack 和 babel
+ plugins:
```js
new webpack.DefinePlugin({
    // window.ENV = 'development'
    ENV: JSON.stringify('development')
})
```


